//! Tier 1: Tone AI
//!
//! This is the first layer of the two-tier AI system.
//! It searches the tone encyclopedia for matching tones based on user input.
//! If no match is found, it uses AI to generate tone recommendations.

use crate::ai_client::AIProvider;
use crate::tone_encyclopedia::{SearchResult, ToneEncyclopedia, ToneEntry, ToneParameters};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::error::Error;

const SEARCH_LIMIT: usize = 5;
const MIN_CONFIDENCE_THRESHOLD: f32 = 0.3;

/// Result from Tier 1 Tone AI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToneAIResult {
    pub source: ToneSource,
    pub tone_description: String,
    pub parameters: ToneParameters,
    pub matched_entry: Option<String>, // Entry ID if from encyclopedia
    pub confidence: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ToneSource {
    Encyclopedia, // Found in encyclopedia
    AIGenerated,  // Generated by AI
    Hybrid,       // Combination of encyclopedia + AI refinement
}

/// Tier 1: Tone AI Engine
pub struct ToneAI {
    encyclopedia: ToneEncyclopedia,
    ai_provider: Option<AIProvider>,
}

impl ToneAI {
    /// Create new Tone AI with encyclopedia
    pub fn new(encyclopedia: ToneEncyclopedia) -> Self {
        Self {
            encyclopedia,
            ai_provider: None,
        }
    }

    /// Set AI provider for fallback generation
    pub fn with_ai_provider(mut self, provider: AIProvider) -> Self {
        self.ai_provider = Some(provider);
        self
    }

    /// Process user request and return tone recommendation
    pub async fn process_request(&self, user_message: &str) -> Result<ToneAIResult, Box<dyn Error>> {
        println!("[TONE AI] Processing request: {}", user_message);

        // Step 1: Search encyclopedia
        let search_results = self.encyclopedia.search(user_message, SEARCH_LIMIT);

        if !search_results.is_empty() {
            let best_match = &search_results[0];

            println!(
                "[TONE AI] Found {} matches in encyclopedia. Best match: {} (score: {:.2})",
                search_results.len(),
                best_match.tone.artist,
                best_match.score
            );

            // If confidence is high enough, use encyclopedia result
            if best_match.score >= MIN_CONFIDENCE_THRESHOLD {
                return Ok(ToneAIResult {
                    source: ToneSource::Encyclopedia,
                    tone_description: format!(
                        "{} - {} - {} | {}",
                        best_match.tone.artist,
                        best_match
                            .tone
                            .album
                            .as_deref()
                            .unwrap_or("Unknown Album"),
                        best_match.tone.song.as_deref().unwrap_or("Unknown Song"),
                        best_match.tone.description
                    ),
                    parameters: best_match.tone.parameters.clone(),
                    matched_entry: Some(best_match.tone.id.clone()),
                    confidence: best_match.score,
                });
            }
        }

        // Step 2: If no good match in encyclopedia, use AI
        println!("[TONE AI] No confident encyclopedia match, using AI fallback...");

        if let Some(ref provider) = self.ai_provider {
            // Build context from encyclopedia if we have partial matches
            let mut context = String::new();
            if !search_results.is_empty() {
                context.push_str("Related tones from encyclopedia:\n");
                for result in search_results.iter().take(3) {
                    context.push_str(&format!(
                        "- {} - {}: {}\n",
                        result.tone.artist,
                        result.tone.album.as_deref().unwrap_or("Unknown"),
                        result.tone.description
                    ));
                }
                context.push('\n');
            }

            let ai_result = self.generate_tone_with_ai(provider, user_message, &context).await?;

            Ok(ai_result)
        } else {
            Err("No encyclopedia match found and no AI provider configured".into())
        }
    }

    /// Generate tone using AI when encyclopedia doesn't have a match
    async fn generate_tone_with_ai(
        &self,
        provider: &AIProvider,
        user_message: &str,
        context: &str,
    ) -> Result<ToneAIResult, Box<dyn Error>> {
        let system_prompt = r#"You are a professional guitar/bass tone specialist AI.
Your job is to analyze tone requests and provide precise parameter recommendations, including creative FX chain ideas when helpful.

When given a tone request, respond with a JSON object containing:
1. A description of the tone
2. Precise parameter values (0.0 to 1.0 range)

REQUIREMENTS:
- If the user explicitly asks for an effect category (delay, reverb, noise gate, EQ), include that section with at least one meaningful parameter.
- If the user explicitly says to keep that category OFF/bypassed, do not include it.
- If the user does NOT mention effects, you may still add supportive processing (e.g., gate, EQ, cab sim, saturation, compression, ambience) if it helps achieve the tone, unless the user explicitly forbids extra effects.

Example output:
```json
{
  "description": "Aggressive thrash metal tone with scooped mids",
  "parameters": {
    "amp": {
      "gain": 0.85,
      "bass": 0.6,
      "mid": 0.3,
      "treble": 0.75,
      "presence": 0.7
    },
    "eq": {
      "80Hz": -2.0,
      "800Hz": -4.0,
      "2kHz": 1.0,
      "5kHz": 2.0
    },
    "effects": [
      {
        "effect_type": "noise_gate",
        "parameters": {"threshold": 0.3}
      },
      {
        "effect_type": "overdrive",
        "parameters": {"drive": 0.4, "tone": 0.6, "level": 0.8}
      }
    ],
    "reverb": {
      "room_size": 0.2,
      "mix": 0.1
    }
  }
}
```

IMPORTANT:
- All amp/effect parameters must be normalized to 0.0-1.0 range
- EQ values are in dB (-12.0 to +12.0)
- Be precise and consistent
- Respect explicit "no / without / keep off / bypass" instructions.
- Respond ONLY with valid JSON
"#;

        let user_prompt = format!("{}\n\nUser request: {}", context, user_message);

        let response = provider.generate(system_prompt, &user_prompt).await?;

        // Parse JSON from response
        let mut parsed = self.parse_ai_tone_response(&response)?;

        // Validate required sections and attempt a single repair pass if the model omitted requested parts.
        let req = detect_requested_sections(user_message);
        let issues = validate_sections(&req, &parsed.parameters);
        if !issues.is_empty() {
            println!("[TONE AI] Model output missing requested sections; attempting repair: {:?}", issues);
            let repair_prompt = format!(
                "{}\n\nYour previous JSON output was missing required sections: {}\nReturn corrected JSON ONLY.\n\nPrevious output:\n{}",
                user_prompt,
                issues.join(", "),
                response
            );
            if let Ok(repair_response) = provider.generate(system_prompt, &repair_prompt).await {
                if let Ok(repair_parsed) = self.parse_ai_tone_response(&repair_response) {
                    let issues2 = validate_sections(&req, &repair_parsed.parameters);
                    if issues2.is_empty() {
                        parsed = repair_parsed;
                    } else {
                        println!(
                            "[TONE AI] Repair attempt still missing sections: {:?} (keeping repair output)",
                            issues2
                        );
                        parsed = repair_parsed;
                    }
                } else {
                    println!("[TONE AI] Repair attempt produced unparsable JSON; keeping original output");
                }
            } else {
                println!("[TONE AI] Repair attempt failed; keeping original output");
            }
        }

        // Respect explicit "no/bypass" instructions (but otherwise allow creative additions).
        let forbidden = detect_forbidden_sections(user_message);
        let removed = prune_forbidden(&forbidden, &mut parsed.parameters);
        if !removed.is_empty() {
            println!("[TONE AI] Removed explicitly forbidden sections/effects: {:?}", removed);
        }

        let mix_adj = apply_mix_heuristics(user_message, &mut parsed.parameters);
        if !mix_adj.is_empty() {
            println!("[TONE AI] Mix heuristics applied: {:?}", mix_adj);
        }

        Ok(ToneAIResult {
            source: if context.is_empty() {
                ToneSource::AIGenerated
            } else {
                ToneSource::Hybrid
            },
            tone_description: parsed.description,
            parameters: parsed.parameters,
            matched_entry: None,
            confidence: 0.7, // AI-generated confidence
        })
    }

    /// Parse AI response JSON
    fn parse_ai_tone_response(&self, response: &str) -> Result<AIToneResponse, Box<dyn Error>> {
        // Extract JSON from markdown code block if present
        let json_str = if response.contains("```json") {
            let start = response.find("```json").unwrap() + 7;
            let end = response[start..].find("```").unwrap() + start;
            &response[start..end]
        } else if response.contains("```") {
            let start = response.find("```").unwrap() + 3;
            let end = response[start..].find("```").unwrap() + start;
            &response[start..end]
        } else {
            response
        };

        let parsed: AIToneResponse = serde_json::from_str(json_str.trim())
            .map_err(|e| format!("Failed to parse AI response: {}", e))?;

        Ok(parsed)
    }

    /// Get encyclopedia statistics
    pub fn get_stats(&self) -> EncyclopediaStats {
        EncyclopediaStats {
            total_tones: self.encyclopedia.count(),
            genres: self.encyclopedia.get_all_genres(),
            artists: self.encyclopedia.get_all_artists(),
        }
    }

    /// Search encyclopedia directly (for testing/debugging)
    pub fn search_encyclopedia(&self, query: &str) -> Vec<SearchResult> {
        self.encyclopedia.search(query, SEARCH_LIMIT)
    }
}

#[derive(Debug, Clone, Copy, Default)]
struct RequestedSections {
    delay: bool,
    reverb: bool,
    gate: bool,
    eq: bool,
    overdrive: bool,
    distortion: bool,
    compressor: bool,
    chorus: bool,
}

fn detect_requested_sections(user_message: &str) -> RequestedSections {
    let s = user_message.to_lowercase();

    fn has_any(s: &str, needles: &[&str]) -> bool {
        needles.iter().any(|n| s.contains(n))
    }

    fn has_negation(s: &str, label: &str) -> bool {
        // Lightweight negation heuristics for common instructions.
        let patterns = [
            format!("no {}", label),
            format!("without {}", label),
            format!("{} off", label),
            format!("{} bypass", label),
            format!("{} bypassed", label),
            format!("keep {} off", label),
            format!("keep {} bypass", label),
            format!("{} kapalı", label),
        ];
        patterns.iter().any(|p| s.contains(p))
    }

    let delay = has_any(&s, &["delay", "echo", "slapback"]) && !has_negation(&s, "delay");
    let reverb = has_any(&s, &["reverb", "room", "hall"]) && !has_negation(&s, "reverb");
    let gate = has_any(&s, &["noise gate", "gate"]) && !has_negation(&s, "gate");
    let eq = (has_any(&s, &[" eq", "equalizer", "hz"]) || s.starts_with("eq")) && !has_negation(&s, "eq");

    let overdrive = has_any(&s, &["overdrive", "tubescreamer", "tube screamer", "screamer", "od"])
        && !has_negation(&s, "overdrive")
        && !has_negation(&s, "tubescreamer");
    let distortion = has_any(&s, &["distortion", "fuzz", "hm-2", "hm2"])
        && !has_negation(&s, "distortion")
        && !has_negation(&s, "fuzz");
    let compressor =
        has_any(&s, &["compressor", "compression", "comp"]) && !has_negation(&s, "compressor");
    let chorus = has_any(&s, &["chorus", "modulation"]) && !has_negation(&s, "chorus");

    RequestedSections {
        delay,
        reverb,
        gate,
        eq,
        overdrive,
        distortion,
        compressor,
        chorus,
    }
}

#[derive(Debug, Clone, Copy, Default)]
struct ForbiddenSections {
    delay: bool,
    reverb: bool,
    eq: bool,
    gate: bool,
    overdrive: bool,
    distortion: bool,
    compressor: bool,
    chorus: bool,
    all_effects: bool,
}

fn detect_forbidden_sections(user_message: &str) -> ForbiddenSections {
    let s = user_message.to_lowercase();

    fn has_any(s: &str, needles: &[&str]) -> bool {
        needles.iter().any(|n| s.contains(n))
    }

    fn has_negation(s: &str, label: &str) -> bool {
        let patterns = [
            format!("no {}", label),
            format!("without {}", label),
            format!("{} off", label),
            format!("{} bypass", label),
            format!("{} bypassed", label),
            format!("keep {} off", label),
            format!("keep {} bypass", label),
            format!("{} kapalı", label),
        ];
        patterns.iter().any(|p| s.contains(p))
    }

    let all_effects = has_any(&s, &["no effects", "without effects", "dry only", "dry signal", "only amp"])
        || has_any(&s, &["efektsiz", "efekt istemiyorum", "dry"]);

    ForbiddenSections {
        delay: has_negation(&s, "delay"),
        reverb: has_negation(&s, "reverb"),
        eq: has_negation(&s, "eq") || has_negation(&s, "equalizer"),
        gate: has_negation(&s, "gate") || has_negation(&s, "noise gate"),
        overdrive: has_negation(&s, "overdrive") || has_negation(&s, "tubescreamer"),
        distortion: has_negation(&s, "distortion") || has_negation(&s, "fuzz"),
        compressor: has_negation(&s, "compressor") || has_negation(&s, "compression"),
        chorus: has_negation(&s, "chorus") || has_negation(&s, "modulation"),
        all_effects,
    }
}

fn validate_sections(req: &RequestedSections, params: &ToneParameters) -> Vec<String> {
    let mut issues = Vec::new();
    if req.delay && params.delay.is_empty() {
        issues.push("delay".to_string());
    }
    if req.reverb && params.reverb.is_empty() {
        issues.push("reverb".to_string());
    }
    if req.eq && params.eq.is_empty() {
        issues.push("eq".to_string());
    }
    if req.gate {
        let has_gate = params
            .effects
            .iter()
            .any(|e| e.effect_type.to_lowercase().contains("gate"));
        if !has_gate {
            issues.push("noise_gate".to_string());
        }
    }
    issues
}

fn prune_forbidden(forbidden: &ForbiddenSections, params: &mut ToneParameters) -> Vec<String> {
    let mut removed = Vec::new();

    if forbidden.delay && !params.delay.is_empty() {
        params.delay.clear();
        removed.push("delay".to_string());
    }
    if forbidden.reverb && !params.reverb.is_empty() {
        params.reverb.clear();
        removed.push("reverb".to_string());
    }
    if forbidden.eq && !params.eq.is_empty() {
        params.eq.clear();
        removed.push("eq".to_string());
    }

    if forbidden.all_effects && !params.effects.is_empty() {
        params.effects.clear();
        removed.push("effects".to_string());
        return removed;
    }

    let before = params.effects.len();
    params.effects.retain(|e| {
        let t = e.effect_type.to_lowercase();
        let is_gate = t.contains("gate");
        let is_overdrive = t.contains("overdrive") || t.contains("tubescreamer") || t.contains("screamer") || t == "od";
        let is_distortion = t.contains("dist") || t.contains("fuzz") || t.contains("hm-2") || t.contains("hm2");
        let is_compressor = t.contains("compress");
        let is_chorus = t.contains("chorus");

        if is_gate && forbidden.gate {
            return false;
        }
        if is_overdrive && forbidden.overdrive {
            return false;
        }
        if is_distortion && forbidden.distortion {
            return false;
        }
        if is_compressor && forbidden.compressor {
            return false;
        }
        if is_chorus && forbidden.chorus {
            return false;
        }
        true
    });

    if params.effects.len() != before {
        removed.push("effects".to_string());
    }

    removed
}

fn apply_mix_heuristics(user_message: &str, params: &mut ToneParameters) -> Vec<String> {
    let s = user_message.to_lowercase();
    let mut notes = Vec::new();

    fn clamp(map: &mut HashMap<String, f64>, key: &str, min: Option<f64>, max: Option<f64>) -> Option<(f64, f64)> {
        let v = map.get_mut(key)?;
        let before = *v;
        if let Some(mx) = max {
            if *v > mx {
                *v = mx;
            }
        }
        if let Some(mn) = min {
            if *v < mn {
                *v = mn;
            }
        }
        if (before - *v).abs() > f64::EPSILON {
            Some((before, *v))
        } else {
            None
        }
    }

    let very_low = s.contains("very low mix")
        || s.contains("super low mix")
        || s.contains("çok düşük")
        || s.contains("cok dusuk")
        || s.contains("çok az")
        || s.contains("cok az");
    let low = very_low
        || s.contains("low mix")
        || s.contains("subtle")
        || s.contains("very subtle")
        || s.contains("just a little")
        || s.contains("tiny")
        || s.contains("do not wash")
        || s.contains("avoid washing");

    if low && !params.delay.is_empty() {
        let max = if very_low { 0.12 } else { 0.20 };
        if let Some((b, a)) = clamp(&mut params.delay, "mix", None, Some(max)) {
            notes.push(format!("delay.mix {:.2} -> {:.2}", b, a));
        }
    }

    if low && !params.reverb.is_empty() {
        let max = if very_low { 0.12 } else { 0.15 };
        if let Some((b, a)) = clamp(&mut params.reverb, "mix", None, Some(max)) {
            notes.push(format!("reverb.mix {:.2} -> {:.2}", b, a));
        }
    }

    notes
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct AIToneResponse {
    description: String,
    parameters: ToneParameters,
}

#[derive(Debug, Clone, Serialize)]
pub struct EncyclopediaStats {
    pub total_tones: usize,
    pub genres: Vec<String>,
    pub artists: Vec<String>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::tone_encyclopedia::{Equipment, ToneEntry};
    use std::collections::HashMap;

    #[tokio::test]
    async fn test_tone_ai_encyclopedia_search() {
        let mut encyclopedia = ToneEncyclopedia::new();

        // Add sample tone
        let tone = ToneEntry {
            id: "metallica_master_battery".to_string(),
            artist: "Metallica".to_string(),
            album: Some("Master of Puppets".to_string()),
            song: Some("Battery".to_string()),
            year: Some(1986),
            genre: Some("Thrash Metal".to_string()),
            instrument: "guitar".to_string(),
            description: "Aggressive rhythm tone".to_string(),
            equipment: Equipment::default(),
            parameters: ToneParameters {
                amp: HashMap::from([
                    ("gain".to_string(), 0.85),
                    ("bass".to_string(), 0.6),
                    ("mid".to_string(), 0.3),
                    ("treble".to_string(), 0.75),
                ]),
                eq: HashMap::new(),
                effects: Vec::new(),
                reverb: HashMap::new(),
                delay: HashMap::new(),
            },
            techniques: Vec::new(),
            tags: vec!["aggressive".to_string()],
        };

        encyclopedia.add_tone(tone);

        let tone_ai = ToneAI::new(encyclopedia);

        // Test search
        let results = tone_ai.search_encyclopedia("Metallica Battery");
        assert_eq!(results.len(), 1);
        assert!(results[0].score > 0.0);
    }

    #[test]
    fn test_json_parsing() {
        let encyclopedia = ToneEncyclopedia::new();
        let tone_ai = ToneAI::new(encyclopedia);

        let json_response = r#"
```json
{
  "description": "Test tone",
  "parameters": {
    "amp": {
      "gain": 0.8
    },
    "eq": {},
    "effects": [],
    "reverb": {},
    "delay": {}
  }
}
```
"#;

        let result = tone_ai.parse_ai_tone_response(json_response);
        assert!(result.is_ok());

        let parsed = result.unwrap();
        assert_eq!(parsed.description, "Test tone");
    }
}
