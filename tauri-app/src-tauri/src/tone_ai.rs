//! Tier 1: Tone AI
//!
//! This is the first layer of the two-tier AI system.
//! It searches the tone encyclopedia for matching tones based on user input.
//! If no match is found, it uses AI to generate tone recommendations.

use crate::ai_client::AIProvider;
use crate::tone_encyclopedia::{SearchResult, ToneEncyclopedia, ToneEntry, ToneParameters};
use serde::{Deserialize, Serialize};
use std::error::Error;

const SEARCH_LIMIT: usize = 5;
const MIN_CONFIDENCE_THRESHOLD: f32 = 0.3;

/// Result from Tier 1 Tone AI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToneAIResult {
    pub source: ToneSource,
    pub tone_description: String,
    pub parameters: ToneParameters,
    pub matched_entry: Option<String>, // Entry ID if from encyclopedia
    pub confidence: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ToneSource {
    Encyclopedia, // Found in encyclopedia
    AIGenerated,  // Generated by AI
    Hybrid,       // Combination of encyclopedia + AI refinement
}

/// Tier 1: Tone AI Engine
pub struct ToneAI {
    encyclopedia: ToneEncyclopedia,
    ai_provider: Option<AIProvider>,
}

impl ToneAI {
    /// Create new Tone AI with encyclopedia
    pub fn new(encyclopedia: ToneEncyclopedia) -> Self {
        Self {
            encyclopedia,
            ai_provider: None,
        }
    }

    /// Set AI provider for fallback generation
    pub fn with_ai_provider(mut self, provider: AIProvider) -> Self {
        self.ai_provider = Some(provider);
        self
    }

    /// Process user request and return tone recommendation
    pub async fn process_request(&self, user_message: &str) -> Result<ToneAIResult, Box<dyn Error>> {
        println!("[TONE AI] Processing request: {}", user_message);

        // Step 1: Search encyclopedia
        let search_results = self.encyclopedia.search(user_message, SEARCH_LIMIT);

        if !search_results.is_empty() {
            let best_match = &search_results[0];

            println!(
                "[TONE AI] Found {} matches in encyclopedia. Best match: {} (score: {:.2})",
                search_results.len(),
                best_match.tone.artist,
                best_match.score
            );

            // If confidence is high enough, use encyclopedia result
            if best_match.score >= MIN_CONFIDENCE_THRESHOLD {
                return Ok(ToneAIResult {
                    source: ToneSource::Encyclopedia,
                    tone_description: format!(
                        "{} - {} - {} | {}",
                        best_match.tone.artist,
                        best_match
                            .tone
                            .album
                            .as_deref()
                            .unwrap_or("Unknown Album"),
                        best_match.tone.song.as_deref().unwrap_or("Unknown Song"),
                        best_match.tone.description
                    ),
                    parameters: best_match.tone.parameters.clone(),
                    matched_entry: Some(best_match.tone.id.clone()),
                    confidence: best_match.score,
                });
            }
        }

        // Step 2: If no good match in encyclopedia, use AI
        println!("[TONE AI] No confident encyclopedia match, using AI fallback...");

        if let Some(ref provider) = self.ai_provider {
            // Build context from encyclopedia if we have partial matches
            let mut context = String::new();
            if !search_results.is_empty() {
                context.push_str("Related tones from encyclopedia:\n");
                for result in search_results.iter().take(3) {
                    context.push_str(&format!(
                        "- {} - {}: {}\n",
                        result.tone.artist,
                        result.tone.album.as_deref().unwrap_or("Unknown"),
                        result.tone.description
                    ));
                }
                context.push('\n');
            }

            let ai_result = self.generate_tone_with_ai(provider, user_message, &context).await?;

            Ok(ai_result)
        } else {
            Err("No encyclopedia match found and no AI provider configured".into())
        }
    }

    /// Generate tone using AI when encyclopedia doesn't have a match
    async fn generate_tone_with_ai(
        &self,
        provider: &AIProvider,
        user_message: &str,
        context: &str,
    ) -> Result<ToneAIResult, Box<dyn Error>> {
        let system_prompt = r#"You are a professional guitar/bass tone specialist AI.
Your job is to analyze tone requests and provide precise parameter recommendations.

When given a tone request, respond with a JSON object containing:
1. A description of the tone
2. Precise parameter values (0.0 to 1.0 range)

Example output:
```json
{
  "description": "Aggressive thrash metal tone with scooped mids",
  "parameters": {
    "amp": {
      "gain": 0.85,
      "bass": 0.6,
      "mid": 0.3,
      "treble": 0.75,
      "presence": 0.7
    },
    "eq": {
      "80Hz": -2.0,
      "800Hz": -4.0,
      "2kHz": 1.0,
      "5kHz": 2.0
    },
    "effects": [
      {
        "effect_type": "noise_gate",
        "parameters": {"threshold": 0.3}
      },
      {
        "effect_type": "overdrive",
        "parameters": {"drive": 0.4, "tone": 0.6, "level": 0.8}
      }
    ],
    "reverb": {
      "room_size": 0.2,
      "mix": 0.1
    }
  }
}
```

IMPORTANT:
- All amp/effect parameters must be normalized to 0.0-1.0 range
- EQ values are in dB (-12.0 to +12.0)
- Be precise and consistent
- Respond ONLY with valid JSON
"#;

        let user_prompt = format!("{}\n\nUser request: {}", context, user_message);

        let response = provider.generate(system_prompt, &user_prompt).await?;

        // Parse JSON from response
        let parsed = self.parse_ai_tone_response(&response)?;

        Ok(ToneAIResult {
            source: if context.is_empty() {
                ToneSource::AIGenerated
            } else {
                ToneSource::Hybrid
            },
            tone_description: parsed.description,
            parameters: parsed.parameters,
            matched_entry: None,
            confidence: 0.7, // AI-generated confidence
        })
    }

    /// Parse AI response JSON
    fn parse_ai_tone_response(&self, response: &str) -> Result<AIToneResponse, Box<dyn Error>> {
        // Extract JSON from markdown code block if present
        let json_str = if response.contains("```json") {
            let start = response.find("```json").unwrap() + 7;
            let end = response[start..].find("```").unwrap() + start;
            &response[start..end]
        } else if response.contains("```") {
            let start = response.find("```").unwrap() + 3;
            let end = response[start..].find("```").unwrap() + start;
            &response[start..end]
        } else {
            response
        };

        let parsed: AIToneResponse = serde_json::from_str(json_str.trim())
            .map_err(|e| format!("Failed to parse AI response: {}", e))?;

        Ok(parsed)
    }

    /// Get encyclopedia statistics
    pub fn get_stats(&self) -> EncyclopediaStats {
        EncyclopediaStats {
            total_tones: self.encyclopedia.count(),
            genres: self.encyclopedia.get_all_genres(),
            artists: self.encyclopedia.get_all_artists(),
        }
    }

    /// Search encyclopedia directly (for testing/debugging)
    pub fn search_encyclopedia(&self, query: &str) -> Vec<SearchResult> {
        self.encyclopedia.search(query, SEARCH_LIMIT)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct AIToneResponse {
    description: String,
    parameters: ToneParameters,
}

#[derive(Debug, Clone, Serialize)]
pub struct EncyclopediaStats {
    pub total_tones: usize,
    pub genres: Vec<String>,
    pub artists: Vec<String>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::tone_encyclopedia::{Equipment, ToneEntry};
    use std::collections::HashMap;

    #[tokio::test]
    async fn test_tone_ai_encyclopedia_search() {
        let mut encyclopedia = ToneEncyclopedia::new();

        // Add sample tone
        let tone = ToneEntry {
            id: "metallica_master_battery".to_string(),
            artist: "Metallica".to_string(),
            album: Some("Master of Puppets".to_string()),
            song: Some("Battery".to_string()),
            year: Some(1986),
            genre: Some("Thrash Metal".to_string()),
            instrument: "guitar".to_string(),
            description: "Aggressive rhythm tone".to_string(),
            equipment: Equipment::default(),
            parameters: ToneParameters {
                amp: HashMap::from([
                    ("gain".to_string(), 0.85),
                    ("bass".to_string(), 0.6),
                    ("mid".to_string(), 0.3),
                    ("treble".to_string(), 0.75),
                ]),
                eq: HashMap::new(),
                effects: Vec::new(),
                reverb: HashMap::new(),
                delay: HashMap::new(),
            },
            techniques: Vec::new(),
            tags: vec!["aggressive".to_string()],
        };

        encyclopedia.add_tone(tone);

        let tone_ai = ToneAI::new(encyclopedia);

        // Test search
        let results = tone_ai.search_encyclopedia("Metallica Battery");
        assert_eq!(results.len(), 1);
        assert!(results[0].score > 0.0);
    }

    #[test]
    fn test_json_parsing() {
        let encyclopedia = ToneEncyclopedia::new();
        let tone_ai = ToneAI::new(encyclopedia);

        let json_response = r#"
```json
{
  "description": "Test tone",
  "parameters": {
    "amp": {
      "gain": 0.8
    },
    "eq": {},
    "effects": [],
    "reverb": {},
    "delay": {}
  }
}
```
"#;

        let result = tone_ai.parse_ai_tone_response(json_response);
        assert!(result.is_ok());

        let parsed = result.unwrap();
        assert_eq!(parsed.description, "Test tone");
    }
}
